---
title: "Travail_final"
author: "Jonathan Rondeau-Leclaire"
date: "31/01/2023"
output: html_document
---

```{r setup, include=FALSE}
library(pacman)
p_load(magrittr, dplyr)
```
### types de forêt
R: rien 
T: Tempérée (Érables, etc)
M: Mixte
B: Boréale
Tous les états peuvent changer, mais $T \longleftrightarrow B$ n'est pas possible.

### Objectif du travail final
Écrire un programme calculant les changements au sein de la communauté d'arbres de la forêt au fil du temps.

# 1. Transformation des abondances en états de départ
### Conditions des différents états de la forêt
'B' si présence de abba ou piru
'T' si présence de acsa ou acpe ou beal ou fagr
'M' si présence de (abba ou piru) et (acsa ou acpe ou beal ou fagr)
'R' si aucun de ces critères n'est rempli

```{r etats}
quadrats <- read.csv2("quadrats.txt")

species <- colnames(quadrats[,3:9])

# états possibles de la forêt
etats <- c("B","M","T","R")
#!!!!!!!! redo
# critères des états
etatsMx <- quadrats %>% 
  mutate(etat_0 = as.factor( # créer la variable etat
    case_when( # la variable est déterminée conditionnellement
      (abba > 0 | piru > 0) & acsa==0 & beal==0 & acpe==0 & fagr==0 ~ "B", # boréale
      abba==0 & piru==0 & (acsa>0 | beal>0 | acpe>0 | fagr>0) ~ "T", # tempérée
      (abba > 0 | piru > 0) & (acsa>0 | beal>0 | acpe>0 | fagr>0) ~ "M", # mixte
      TRUE ~ "R"))) %>% # sinon, rien!
  mutate(etat_0 = factor(etat_0, levels = etats)) %>% dplyr::select(etat_0)
summary(etatsMx)
```

# 2. L'état $t+1$
## Matrice de transition entre les différents états
Elle montre la probabilité d'obtenir un état au temps $t+1$ étant donné l'état au temps $t$.
```{r}
transMx <- read.table("matrice_transitions.txt") 
rownames(transMx) <- etats
colnames(transMx) <- etats
transMx
```


## Fonction pour tirer au hasard l'état $t+1$   
```{r fonction}
etat.fun <- function(etat) {
  res <- rmultinom(n=1, size=1, 
                   prob=transMx[etat,])
  return(etats[which(res==1)])
}
```

# 3. Fonction de simulation rapportant la composition sur N pas de temps
```{r simulation}
simul.fun2 <- function(N,   # nombre de pas de temps 
                       mx){ # matrice de l'état initial
  set.seed(123)
  for (i in 0:(N-1)){ # de l'état 0 à l'état 
    if (i==0){pas <- "etat_0"}
    # création d'une vecteur des états t+1 :
    nom <- paste0("etat_",i+1) # création d'un nom pour l'état t+1
    etat_t <- mx[[pas]] # extraire le vecteur du temps t
    liste <- list() # création d'une liste vide à populer
    for (j in 1:length(etat_t)){ # populer la liste avec notre fonction
      liste[[j]] <- etat.fun(etat_t[j]) # prédire le temps t+1
    }
    mx[[nom]] <- factor(unlist(liste),  # transformer en vecteur et l'ajouter 
                        levels = etats) # à la matrice
    pas <- nom # le temps t+1 devient le temps t dans la boucle
    #remove(liste)
  }
  return(mx)
}
```

# Alternativement on peut éviter la boucle grâce à sapply() :
```{r simulation}
simul.fun <- function(N, mx){
  set.seed(123)
  for (i in 0:(N-1)){ # parce qu'on commence à l'état 0 et on cherche t+1
      if (i==0){pas <- "etat_0"}
      # création d'une vecteur des états t+1 :
      nom <- paste0("etat_",i+1) # création d'un nom
            # ajout d'une colonne dans la matrice: 
      mx[[nom]] <- factor(unlist( # sapply crée des listes, on veut un vecteur
          sapply(mx[[pas]], etat.fun)), # tirage au sort avec notre fonction
                          levels = etats) # pour conserver l'ordre des facteurs
      pas <- nom # le temps t+1 devient le temps t dans la boucle
  ###! summarize and create new df (created before loop?)
      }
  return(mx)
}

simulation_100 <- simul.fun(100,etatsMx) 
#summary(simulation %>% select(contains("etat")))
composition <- summary(simulation_100)
apply(composition, 2, function(x){x/sum(x)})

system.time(simul.fun(10,etatsMx))
system.time(simul.fun(100,etatsMx))
```

# 5. Questions à répondre



