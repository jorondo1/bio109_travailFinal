---
title: "Travail_final"
author: "Jonathan Rondeau-Leclaire"
date: "31/01/2023"
output: html_document
---

```{r setup, include=FALSE}
library(pacman)
p_load(tidyverse)
```
### types de forêt
R: rien 
T: Tempérée (Érables, etc)
M: Mixte
B: Boréale
Tous les états peuvent changer, mais $T \longleftrightarrow B$ n'est pas possible.

### Objectif du travail final
Écrire un programme calculant les changements au sein de la communauté d'arbres de la forêt au fil du temps.

# 1. Transformation des abondances en états de départ
### Conditions des différents états de la forêt
'B' si présence de abba ou piru
'T' si présence de acsa ou acpe ou beal ou fagr
'M' si présence de (abba ou piru) et (acsa ou acpe ou beal ou fagr)
'R' si aucun de ces critères n'est rempli

```{r etats}
quadrats <- read.csv2("quadrats.txt")

species <- colnames(quadrats[,3:9])

# critères des états
etatsMx <- quadrats %>% 
  mutate(etat_0 = as.factor( # créer la variable etat
    case_when( # la variable est déterminée conditionnellement
      (abba > 0 | piru > 0) & acsa==0 & beal==0 & acpe==0 & fagr==0  ~ "B", # boréale
      abba==0 & piru==0 & (acsa>0 | beal>0 | acpe>0 | fagr>0) ~ "T", # tempérée
      (abba > 0 | piru > 0) & (acsa>0 | beal>0 | acpe>0 | fagr>0) ~ "M", # mixte
      TRUE ~ "R"))) %>% # sinon, rien!
  dplyr::select(etat_0, borx, bory) # on garde seulement les états et les coordonnées

summary(etatsMx$etat)
```

# 2. L'état $t+1$
## Matrice de transition entre les différents états
Elle montre la probabilité d'obtenir un état au temps $t+1$ étant donné l'état au temps $t$.
```{r}
transMx <- read.table("matrice_transitions.txt") 
etats <- c("B","M","T","R")
rownames(transMx) <- etats
colnames(transMx) <- etats
transMx
```

## Fonction pour tirer au hasard l'état $t+1$   
```{r fonction}

etat.fun <- function(etat) {
  p <- transMx[etat,]
  res <- rmultinom(n=1, size=1, prob=p)
  etats[which(res==1)]
}

# par exemple, on tire l'état au temps t+1 d'un quadrat de forêt Boréale au temps t:
etat.fun("B")
```

# 3. Fonction de simulation rapportant la composition sur N pas de temps
```{r simulation}
simul.fun <- function(N, mx){
  for (i in 0:N){
      if (i==0){pas <- "etat_0"}
      # création d'une vecteur des états t+1 :
      pasVecteur <- unlist(lapply(mx[[pas]], etat.fun)) # tirage au sort
      nom <- paste0("etat_",i+1) # création du nouveau nom de l'état t+1
      mx[[nom]] <- as.factor(pasVecteur) # ajout d'une colonne dans la matrice
      pas <- nom # le temps t+1 devient le temps t dans la boucle
  }
  return(mx)
}
simulation <- simul.fun(5,etatsMx)
summary(simulation %>% select(contains("etat")))

```




